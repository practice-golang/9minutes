<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">

    <!-- <script src="https://cdn.jsdelivr.net/npm/vue@2.6.0"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.17/dist/sweetalert2.all.min.js"></script>

    <link rel="stylesheet" href="/assets/css/sakura.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/normalize.css" type="text/css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tinymce/5.8.1/tinymce.min.js"></script>
</head>

<body>
    <div id="app" v-show="isShow">
        <h1>{{table}}</h1>
        <table>
            <!-- <tr v-if="!Object.values(contents).includes('writer-name')"> -->
            <tr v-if="contents['is-member'] == 'Y' || mode == 'edit'">
                <td>{{contents['writer-name']}}</td>
            </tr>
            <tr v-else>
                <td><input v-model="contents['writer-name']" placeholder="name" /></td>
                <td><input v-model="contents['writer-password']" placeholder="password" /></td>
            </tr>
            <tr>
                <td><input v-model="contents.title" placeholder="Title" /></td>
            </tr>
            <tr>
                <td colspan="2">
                    <!-- <textarea id="editor" v-model="contents.content"></textarea> -->
                    <textarea id="editor" v-model="contents.content" class="editors"></textarea>
                </td>
            </tr>
        </table>

        <input type="file" name="input-file" multiple @input="inputHandler" />
        <div id="drop-area" @drop="dropHandler" @dragover="dragOverHandler">
            <p>Drag files to here</p>
        </div>
        <!-- <button onclick="uploadFINISH()">업로드 마무리</button> -->
        <div id="msg"></div>

        <button onclick="history.back()">Cancel</button>
        <button @click="writePost()">Write</button>
    </div>
</body>

<script>
    function showError(status) {
        switch (status) {
            case 400:
                swal.fire("Bad request", "Bad request", "error").then(() => {
                    localStorage.removeItem("token")
                    location.href = "/users/login"
                })
                break
            case 401:
                swal.fire("Unauthorized", "need login", "error").then(() => {
                    localStorage.removeItem("token")
                    location.href = "/users/login"
                })
                break
            case 403:
                swal.fire("Forbidden", "You don't have permission to access", "error").then(() => {
                    window.history.back()
                })
                break
            default:
                swal.fire("Error occured", "", "error")
                break
        }

        return false
    }

    tinymce.init({
        selector: "textarea.editors",
        mode: "textareas",
        theme: "silver",
        height: "480",
        force_p_newlines: false,
        force_br_newlines: true,
        // forced_root_block: false,
        forced_root_block: '',
        convert_newlines_to_brs: false,
        remove_linebreaks: true,
        // branding: false
    })
    Vue.prototype.location = window.location
    const vm = new Vue({
        el: "#app",
        data: {
            restURIdomain: window.location.protocol + "//" + window.location.host,
            restURI: window.location.protocol + "//" + window.location.host,
            isShow: false,
            table: "'##__TABLE_NAME__##'",
            boardCode: "'##__BOARD_CODE__##'",
            mode: "write",
            id: "",
            isAdmin: false,
            paramIsMember: "",
            contents: {
                title: "",
                content: "",
                "is-member": "N",
                "writer-name": "",
                "writer-password": ""
            },
            formData: new FormData(),
            uploadTmpPath: "data_tmp",
            uriUploadTMP: "/api/upload/tmp",
            uriUploadFINISH: "/api/upload/finish",
            uploadHeaderJSON: {
                "Accept": "application/json",
                "Content-Type": "application/json",
            },
            uploadOrderCount: 0,
        },
        mounted() {
            const uri = new URL(String(document.location.href))
            this.mode = String(uri.searchParams.get("mode"))
            this.id = String(uri.searchParams.get("id"))
            this.paramIsMember = String(uri.searchParams.get("member"))

            this.initData()
        },
        methods: {
            async initData() {
                await this.checkLogedIn()
                await this.checkPermission()
                if (this.mode == "edit" && this.id != null) {
                    await this.getData()
                }
            },
            async checkLogedIn() {
                let result = false
                let reissue = false
                let response = ""
                let r = ""

                const token = localStorage.getItem('token')

                if (token != null) {
                    response = await fetch(this.restURIdomain + "/api/user/token/verify", {
                        method: "POST",
                        headers: { "Authorization": "Bearer " + token }
                    })
                    r = await response.json()
                    if (response.ok) {
                        if (r.msg == "OK") { result = true }
                    } else if (r.expired) {
                        reissue = true
                    }

                    if (!result && reissue) {
                        response = await fetch(this.restURIdomain + "/api/user/token", {
                            method: "GET",
                            headers: { "Authorization": "Bearer " + token }
                        })

                        if (response.ok) {
                            r = await response.json()
                            localStorage.setItem("token", r.token)
                            result = true
                        } else {
                            localStorage.removeItem("token")
                            result = false
                        }
                    }
                }

                if (!result) {
                    swal.fire("Authorization failed", "Token is not exist or invalid", "error").then(() => {
                        location.href = "/users/login"
                    })
                } else {
                    this.token = token
                }
            },
            async checkPermission() {
                let headers = {
                    "Accept": "application/json",
                    "Content-Type": "application/json",
                }

                const token = localStorage.getItem('token')

                if (token != undefined && token != null) {
                    Object.assign(headers, { "Authorization": "Bearer " + token })
                }

                const params = "?code=" + this.boardCode + "&mode=" + this.mode
                let response = await fetch(this.restURI + "/api/user/permission" + params, {
                    method: "GET",
                    headers: headers,
                })

                if (response.ok) {
                    const contents = await response.json()
                    await this.getUserInfo()
                    if (this.mode != "edit") {
                        this.isShow = true
                    }
                    return false
                }

                showError(response.status)
                return false
            },
            async getUserInfo() {
                let headers = {
                    "Accept": "application/json",
                    "Content-Type": "application/json",
                }

                const token = localStorage.getItem('token')

                if (token != undefined && token != null) {
                    Object.assign(headers, { "Authorization": "Bearer " + token })

                    let response = await fetch(this.restURI + "/api/user/info", {
                        method: "GET",
                        headers: headers,
                    })

                    if (response.ok) {
                        const userInfo = await response.json()
                        if (this.paramIsMember != "n") {
                            this.contents["writer-name"] = userInfo.username
                            this.contents["is-member"] = "Y"
                            if (userInfo.admin == "Y") {
                                this.isAdmin = true
                            }
                        }
                        return false
                    }

                    showError(response.status)
                }

                return false
            },
            async getData() {
                let keywords = [{ idx: this.id }]

                let headers = {
                    "Accept": "application/json",
                    "Content-Type": "application/json",
                }

                const token = localStorage.getItem('token')

                // if (token == null || this.paramIsMember == "n") {
                if (this.paramIsMember == "n") {
                    const confirm = await swal.fire({
                        title: "Password",
                        input: "password",
                        icon: "warning",
                        showCancelButton: true,
                        confirmButtonText: "OK",
                        cancelButtonText: "Cancel"
                    })

                    if (!confirm.isConfirmed) {
                        history.back()
                        return false
                    }

                    keywords.push({ "writer-password": confirm.value })
                }

                if (token != undefined && token != null) {
                    Object.assign(headers, { "Authorization": "Bearer " + token })
                }

                const params = "?code=" + this.boardCode + "&mode=edit"

                let response = await fetch(this.restURI + "/api/basic-board/contents" + params, {
                    method: "POST",
                    headers: headers,
                    body: JSON.stringify({
                        keywords: keywords,
                        options: { count: 1 },
                        table: this.table
                    })
                })

                if (response.ok) {
                    const data = await response.json()
                    if (data.length == 0) {
                        swal.fire("Forbidden", "You can not edit", "error").then(() => {
                            history.back()
                        })
                        return false
                    }

                    let contents = data[0]

                    this.contents = contents
                    await tinymce.activeEditor.setContent(this.contents.content)

                    if (this.mode == "edit") {
                        this.isShow = true
                    }
                }

                return false
            },
            async writePost() {
                let files = new Array()
                this.formData.forEach(function (value, key) {
                    files.push(JSON.parse(value))
                })

                this.uploadFINISH()

                let requestMethod = "PUT"
                this.contents.content = await tinymce.activeEditor.getContent()

                if (this.mode == "edit" && this.id != null) {
                    requestMethod = "PATCH"
                    this.contents.idx = this.id
                }

                let headers = {
                    "Accept": "application/json",
                    "Content-Type": "application/json",
                }

                const token = localStorage.getItem('token')

                if (token != undefined && token != null) {
                    Object.assign(headers, { "Authorization": "Bearer " + token })
                }

                const params = "?code=" + this.boardCode + "&mode=write"

                let response = await fetch(this.restURI + "/api/basic-board/contents" + params, {
                    method: requestMethod,
                    headers: headers,
                    body: JSON.stringify({
                        data: this.contents,
                        files: files,
                        table: this.table
                    })
                })

                if (response.ok) {
                    const result = await response.json()
                    location.href = this.restURI + "/board?code=" + this.boardCode + "&mode=read&id=" + result["last-id"]
                    return false
                }

                showError(response.status)
                return false
            },
            readFile(file) {
                return new Promise((resolve, reject) => {
                    let fr = new FileReader()
                    fr.onload = x => resolve(fr.result)
                    // fr.readAsText(file)
                    fr.readAsBinaryString(file)
                })
            },
            futch(url, opts = {}, onProgress) {
                return new Promise((res, rej) => {
                    var xhr = new XMLHttpRequest()
                    xhr.open(opts.method || 'get', url)
                    for (var k in opts.headers || {}) {
                        xhr.setRequestHeader(k, opts.headers[k])
                    }
                    xhr.onload = e => res(e.target.responseText)
                    xhr.onerror = rej
                    if (xhr.upload && onProgress) {
                        // event.loaded / event.total * 100 ; //event.lengthComputable
                        xhr.upload.onprogress = onProgress
                    }
                    xhr.send(opts.body)
                })
            },
            async uploadTMP(name, type, content, ord) {
                const data = {
                    name: name,
                    type: type,
                    content: content,
                }

                const response = await this.futch(this.uriUploadTMP, {
                    method: "POST",
                    headers: this.uploadHeaderJSON,
                    body: JSON.stringify(data),
                }, (e) => {
                    let pct = ((e.loaded / e.total) * 100).toFixed(2)

                    console.log("file" + ord, pct)

                    document.getElementById("progress-bar" + ord).value = pct
                    document.getElementById("progress-bar" + ord).setAttribute("data-label", pct + "%")
                }).catch((error) => { })

                let success = false
                if (response != undefined) {
                    success = true

                    const responseJSON = JSON.parse(response)
                    if (responseJSON.msg == "You cannot upload") {
                        success = false
                    }
                }

                if (success) {
                    const obj = JSON.parse(response)

                    this.formData.append("file" + ord, response)
                    this.showRemoteObject(obj, ord)
                } else {
                    swal.fire("Upload failed", "", "error")
                    this.formData.delete("file" + ord)
                    const cavity = document.getElementById("file-cavity" + ord)
                    cavity.remove()
                }
            },
            async readFormData(files) {
                console.log("Begin Count: ", this.uploadOrderCount)

                let ord = 0

                for (let i = 0; i < files.length; i++) {
                    const fcontent = btoa(await this.readFile(files[i]))
                    const fname = files[i].name
                    const ftype = files[i].type

                    this.uploadTMP(fname, ftype, fcontent, (this.uploadOrderCount + i).toString())

                    ord = this.uploadOrderCount + i
                }

                this.uploadOrderCount = ord + 1
            },
            dropHandler(ev) {
                // console.log('File(s) dropped')

                ev.preventDefault()

                const files = new Array()

                for (var i = 0; i < ev.dataTransfer.files.length; i++) {
                    const cavity = document.createElement("div")
                    cavity.setAttribute("id", "file-cavity" + (this.uploadOrderCount + i))
                    cavity.setAttribute("class", "file-cavity")

                    const progress = document.createElement("progress")
                    progress.setAttribute("id", "progress-bar" + (this.uploadOrderCount + i))
                    progress.setAttribute("value", "0")
                    progress.setAttribute("max", "100")
                    cavity.appendChild(progress)

                    msg.appendChild(cavity)

                    files.push(ev.dataTransfer.files[i])
                }
                this.readFormData(files)
            },
            dragOverHandler(ev) {
                // console.log('File(s) in drop zone')

                ev.preventDefault()
            },
            async inputHandler(event) {
                const input = event.target

                if (input.files.length == 0) {
                    return false // Empty
                }

                for (var i = 0; i < input.files.length; i++) {
                    const cavity = document.createElement("div")
                    cavity.setAttribute("id", "file-cavity" + (this.uploadOrderCount + i))
                    cavity.setAttribute("class", "file-cavity")

                    const progress = document.createElement("progress")
                    progress.setAttribute("id", "progress-bar" + (this.uploadOrderCount + i))
                    progress.setAttribute("value", "0")
                    progress.setAttribute("max", "100")
                    cavity.appendChild(progress)

                    msg.appendChild(cavity)
                }

                await this.readFormData(input.files)

                document.getElementsByName("input-file")[0].value = ""
            },
            showRemoteObject(obj, ord) {
                const cavity = document.getElementById("file-cavity" + ord)

                switch (obj.type) {
                    case "image/jpeg":
                    case "image/png":
                        const img = document.createElement("img")
                        img.setAttribute("id", "img" + ord)
                        img.setAttribute("src", this.uploadTmpPath + "/" + obj.tmp_name)
                        img.setAttribute("width", "100")
                        cavity.appendChild(img)

                        const iname = document.createElement("span")
                        iname.setAttribute("id", "imgname" + ord)
                        iname.innerText = obj.name
                        cavity.appendChild(iname)

                        const idel = document.createElement("button")
                        idel.setAttribute("id", "del-img" + ord)
                        idel.onclick = () => this.deleteEntry(ord)
                        idel.innerText = "X"
                        cavity.appendChild(idel)

                        break
                    default:
                        const fimg = document.createElement("img")
                        fimg.setAttribute("id", "img" + ord)
                        fimg.setAttribute("src", "file.svg")
                        fimg.setAttribute("width", "100")
                        cavity.appendChild(fimg)

                        const fname = document.createElement("span")
                        fname.setAttribute("id", "filename" + ord)
                        fname.innerText = obj.name
                        cavity.appendChild(fname)

                        const fdel = document.createElement("button")
                        fdel.setAttribute("id", "del-file" + ord)
                        fdel.onclick = () => this.deleteEntry(ord)
                        fdel.innerText = "X"
                        cavity.appendChild(fdel)

                        break
                }

                return false
            },
            async deleteEntry(ord) {
                const obj = JSON.parse(this.formData.get("file" + ord))
                const data = {
                    name: obj.name,
                    tmp_name: obj.tmp_name,
                    type: obj.type
                }
                const response = await fetch(this.uriUploadTMP, {
                    method: "DELETE",
                    headers: this.uploadHeaderJSON,
                    body: JSON.stringify(data)
                })

                this.formData.delete("file" + ord)

                const cavity = document.getElementById("file-cavity" + ord)
                cavity.remove()
            },
            async uploadFINISH() {
                let data = new Array()
                this.formData.forEach(function (value, key) {
                    data.push(JSON.parse(value))
                })

                const response = await fetch(this.uriUploadFINISH, {
                    method: "POST",
                    headers: this.uploadHeaderJSON,
                    body: JSON.stringify(data)
                })

                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    const resultJSON = await response.json()
                    console.log(resultJSON)
                } else {
                    const resultTEXT = await response.text()
                    console.log(resultTEXT)
                }

                swal.fire("Done", "", "success").then(() => {
                    while (msg.firstChild) {
                        msg.removeChild(msg.lastChild)
                    }
                })
            }
        }
    })
</script>

<style>
    body {
        margin: 0;
        padding: 0.5em;
        max-width: 100%;
    }

    #app {
        width: 100%;
    }

    #drop-area {
        border: 5px solid blue;
        width: 200px;
        height: 100px;
    }

    #msg {
        display: flex;
    }

    /*
    Progress bar
    https: //stackoverflow.com/questions/41429906/how-to-display-data-label-inside-html5-progress-bar-cross-browser
    https: //stackoverflow.com/questions/65612948/change-the-color-of-webkit-progress-value-from-javascript
    */

    .file-cavity {
        position: relative;
        width: 170px;
        height: 120px;
    }

    progress::-webkit-progress-value {
        background-color: cadetblue;
    }

    progress {
        text-align: center;
        border: none;
        color: white;
        opacity: .5;
        position: relative;

        top: 60px;
        z-index: 100;
    }

    progress:before {
        content: attr(data-label);
        font-size: 0.8em;
        position: absolute;
        left: 0;
        right: 0;
    }

    .file-cavity>* {
        position: absolute;
        left: 0px;
    }

    .file-cavity>span {
        font-size: 0.8em;
        top: 90px;
    }

    .file-cavity>button {
        left: 130px;
    }
</style>

</html>